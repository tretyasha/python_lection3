#алгоритмы 
# алгоритмом назыаается набор инструкций для выполнения той или иной задачи.
# в принципе, любой фрагмент програмнного кода можно называть алгоритмом,
# но мы с вами рассмотрим 2 самых интресных алгоритма сортировок:
# быстрая сортировка
# сортировка слиянием 

# быстрая сортировка принадлежит к такой стратегии как разделяй и властвуй,т.е. мы делим что-то большое на что-то маленькое и вполне реальное

def quick_sort(array):
    if len(array) <=1: #первым действием указали базис нашей рекурсии,т.е. то место когда наша рекурсия будет завершать нашу работу
        return array #соответственно если длина меньше единицы то мы возвращаем массив,а иначе будем что-то делать.создадим переменную pivot
    else:
        pivot=array[0]
    less=[i for i in array[1:] if i <= pivot ]
    greater=[i for i in array[1:] if i > pivot ] #соответственно создадим второй массив где элементы будут больше pivot 
    return quick_sort(less)+[pivot]+quick_sort(greater) #рекурсия  return less+pivot+greater,но мы знаем что они не отсортированы и поэтому будем их сортировать quick sort

# print(quick_sort([14,5,9,6,3,58,7,5,2,7]))
print(quick_sort([2,5,10]))

# Быстрая сортировка
# ● 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии
# добавляется список [10]
# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5,
# 10]